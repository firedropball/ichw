## 停机问题
### 为什么要证明停机问题：
为了证明计算机无法解决所有问题  
### 证明方法：
- 构造了一个程序a，假设它能判断一个程序是否会停机。  
  - 接着我们再构造一个“不听话”程序b：  
    - 如果b发现a认为自己能停机，它就不停机  
    - 否则，它就停机  
- 那么，a无法判断b是否会停机了，所以不存在这样一个万能的a。  
### 数学原理：
逻辑上的不自洽性（类似上帝悖论，理发师悖论）
 ________
 ## 介绍
 >假定大家能理解无符号整数表示和计算机加法的原理  
  则同学们，我们如何表示正负号呢？  
  那么大家很容易想到，在2进制前面加上一位，用这一位来表示正负号，这就是原码  
  但这会出现两个问题，一是从你的角度来算2-1=1；  
  但计算机本质上是算了2+（-1），  
  如果让你这么算，你当然还是会算出0，  
  但计算机和你的算法不一样，它会算(010)^(101)=111=-3  
  这显然不对，因为从计算机看来，此时-10>-1，负数越小，它认为越大，  
  所以我们要把负数除符号外所有数0，1颠倒，这就是反码  
  但这样还有一个问题，就是会有两个0，如0000，1111都代表零，  
  这样也不好，比如比较两个零是否相同时，如果是0000和1111比，  
  计算机会认为它不等，除非此时你加一个专门的判断程序，但这也太麻烦了  
  所以我们不妨把负数全都往前移一位，这就是补码，就能解决减法的问题了。  
  --------
  ## IEEE浮点数表示
16个bit  
  
| Sign | Exp | Frac | Value |  
| ------ | ------ | ------ | ------ |  
| * | 000000 | 00000000 | ±0 |  
| 0 | 011111 | 00000000 | +1.0 |  
| 1 | 011111 | 00000000 | -1.0 |  
| 1 | 111110 | 11111111 | \\(+(2-2^{−23}) × 2^{127}\) |  
| * | 111111 | 00000000 | ±∞ |  
| 0 | 111111 | Non Zero | NaN |  
